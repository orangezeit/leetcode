struct StaticUnion {
    vector<int> parents, ranks;
    StaticUnion(int n) : parents(n), ranks(n) {
        iota(parents.begin(), parents.end(), 0);
    }

    int find(const int& x) {
        if (x != parents[x])
            parents[x] = find(parents[x]);
        return parents[x];
    }

    void unite(const int& x, const int& y) {
        int px(find(x)), py(find(y));
        if (px == py) return;
        ranks[px] >= ranks[py] ? parents[py] = px : parents[px] = py;
        if (ranks[px] == ranks[py]) ranks[px]++;
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n(graph.size());

        auto group = [&](const int& r) {
            StaticUnion uf(n);
            for (int i = 0; i < n; ++i)
                for (int j = i + 1; j < n; ++j) {
                    if (i == r || j == r) continue;
                    if (graph[i][j])
                        uf.unite(i, j);
                }
            vector<int> cnts(n);
            vector<bool> groups(n);
            int res(0);
            for (int i = 0; i < n; ++i) cnts[uf.find(i)]++;
            for (const int& i: initial) {
                if (groups[uf.parents[i]]) continue;
                res += cnts[uf.parents[i]];
                groups[uf.parents[i]] = true;
            }
            return res;
        };

        int num(n), s(n);

        for (const int& i: initial) {
            int temp = group(i);
            if (temp < s || temp == s && num > i) {
                s = temp;
                num = i;
            }
        }
        return num;
    }
};
