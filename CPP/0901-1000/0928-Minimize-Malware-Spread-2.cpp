struct UnionFind {
    vector<int> parents, ranks;
    UnionFind(int n) {
        parents.resize(n);
        ranks.resize(n);
        for (int i = 0; i < n; ++i) parents[i] = i;
    }
    int find(int x) {
        if (x != parents[x]) parents[x] = find(parents[x]);
        return parents[x];
    }
    void unite(int x, int y) {
        int px(find(x)), py(find(y));
        if (px == py) return;
        if (ranks[px] > ranks[py]) parents[py] = px;
        else if (ranks[px] < ranks[py]) parents[px] = py;
        else {
            parents[py] = px;
            ranks[px]++;
        }
    }
};

class Solution {
public:
    int grouping(const vector<vector<int>>& graph, const vector<int>& initial, const int& r, const int& g) {
        UnionFind uf(g);

        for (int i = 0; i < g; ++i)
            for (int j = i + 1; j < g; ++j) {
                if (i == r || j == r) continue;
                if (graph[i][j])
                    uf.unite(i, j);
            }

        unordered_map<int, int> record;
        unordered_set<int> heads;
        for (int i = 0; i < g; ++i)
            record[uf.find(i)]++;
        for (const int& i: initial)
            heads.insert(uf.parents[i]);
        int ans(0);
        for (const int& h: heads)
            ans += record[h];
        return ans;
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        int num(initial[0]);
        int s = INT_MAX;

        for (const int& i: initial) {
            int temp = grouping(graph, initial, i, graph.size());

            if (temp < s || temp == s && num > i) {
                s = temp;
                num = i;
            }
        }
        return num;
    }
};
