class UnionFind {
private:
    unordered_map<int, int> parents, ranks;
public:
    UnionFind(int n) {
        for (int i = 0; i < n; ++i) {
            parents[i] = i;
            ranks[i] = 0;
        }
    }

    int find(int x) {
        if (x != parents[x])
            parents[x] = find(parents[x]);
        return parents[x];
    }

    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);

        if (ranks[px] > ranks[py])
            parents[py] = px;
        else if (ranks[px] < ranks[py])
            parents[px] = py;
        else {
            parents[py] = px;
            ranks[px]++;
        }
    }
};

class Solution {
public:

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        UnionFind u = UnionFind(graph.size());

        for (int i = 0; i < graph.size(); ++i)
            for (int j = i + 1; j < graph.size(); ++j)
                if (graph[i][j])
                    u.unite(i, j);

        unordered_map<int, unordered_set<int>> record;

        for (int i = 0; i < graph.size(); ++i)
            record[u.find(i)].insert(i);

        int s = 0;
        int num = initial[0];

        for (int i = 0; i < initial.size(); ++i) {
            int ns = record[u.find(initial[i])].size();
            if (ns >= s) {
                s = ns;
                num = min(num, initial[i]);
            }
        }


        return num;
    }
};
